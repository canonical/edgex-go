#!/bin/bash

logger "edgexfoundry CONFIGURE hook START"

# TODO: source from another file???
declare -A conf_to_env

# [Writable] - not yet supported
# conf_to_env["writable.log-level"]="BootTimeout"

# [Service]
conf_to_env["service.boot-timeout"]="SERVICE_BOOTTIMEOUT"
conf_to_env["service.check-interval"]="SERVICE_CHECKINTERVAL"
conf_to_env["service.host"]="SERVICE_HOST"
conf_to_env["service.server-bind-addr"]="SERVICE_SERVERBINDADDR"
conf_to_env["service.port"]="SERVICE_PORT"
conf_to_env["service.protocol"]="SERVICE_PROTOCOL"
conf_to_env["service.max-result-count"]="SERVICE_MAXRESULTCOUNT"
conf_to_env["service.startup-msg"]="SERVICE_STARTUPMSG"
conf_to_env["service.timeout"]="SERVICE_TIMEOUT"

# [Registry]
conf_to_env["registry.host"]="REGISTRY_HOST"
conf_to_env["registry.port"]="REGISTRY_PORT"
conf_to_env["registry.type"]="REGISTRY_TYPE"

# [Clients.Metadata]
conf_to_env["clients.metadata.host"]="CLIENTS_METADATA_HOST"
conf_to_env["clients.metadata.port"]="CLIENTS_METADATA_PORT"
conf_to_env["clients.metadata.protocol"]="CLIENTS_METADATA_PROTOCOL"

# [Clients.Notifications] -- restriced to core-metata, scheduler, and SMA?
conf_to_env["clients.notifications.host"]="CLIENTS_METADATA_HOST"
conf_to_env["clients.notifications.port"]="CLIENTS_METADATA_PORT"
conf_to_env["clients.notifications.protocol"]="CLIENTS_METADATA_PROTOCOL"
# [Databases]
conf_to_env["databases.primary.host"]="DATABASES_PRIMARY_HOST"
conf_to_env["databases.primary.name"]="DATABASES_PRIMARY_NAME"
conf_to_env["databases.primary.password"]="DATABASES_PRIMARY_PASSWORD"
conf_to_env["databases.primary.username"]="DATABASES_PRIMARY_USERNAME"
conf_to_env["databases.primary.port"]="DATABASES_PRIMARY_PORT"
conf_to_env["databases.primary.timeout"]="DATABASES_PRIMARY_TIMEOUT"
conf_to_env["databases.primary.type"]="DATABASES_PRIMARY_TYPE"
# [MessageQueue]
#conf_to_env["messagequeue.protocol"]="MESSAGEQUEUE_PROTOCOL"
#conf_to_env["messagequeue.host"]="MESSAGEQUEUE_HOST"
#conf_to_env["messagequeue.port"]="MESSAGEQUEUE_PORT"
#conf_to_env["messagequeue.type"]="MESSAGEQUEUE_TYPE"
conf_to_env["messagequeue.topic"]="MESSAGEQUEUE_TOPIC"
# [MessageQueue.Optional] - not yet supported
# [SecretStore]
conf_to_env["secretstore.host"]="SECRETSTORE_HOST"
conf_to_env["secretstore.port"]="SECRETSTORE_PORT"
conf_to_env["secretstore.path"]="SECRETSTORE_PATH"
conf_to_env["secretstore.protocol"]="SECRETSTORE_PROTOCOL"
conf_to_env["secretstore.root-ca-cert-path"]="SECRETSTORE_ROOTCACERTPATH"
conf_to_env["secretstore.server-name"]="SECRETSTORE_SERVERNAME"
conf_to_env["secretstore.token-file"]="SECRETSTORE_TOKENFILE"
conf_to_env["secretstore.additional-retry-attempts"]="SECRETSTORE_ADDITIONALRETRYATTEMPTS"
conf_to_env["secretstore.retry-wait-period"]="SECRETSTORE_RETRYWAITPERIOD"
# [SecretStore.Authentication]
conf_to_env["secretstore.authentication.auth-type"]="SECRETSTORE_AUTHENTICATION_AUTHTYPE"
# support-notifications options
# [Smtp]
conf_to_env["smtp.host"]="SMTP_HOST"
conf_to_env["smtp.username"]="SMTP_USERNAME"
conf_to_env["smtp.password"]="SMTP_PASSWORD"
conf_to_env["smtp.port"]="SMTP_PORT"
conf_to_env["smtp.sender"]="SMTP_SENDER"
conf_to_env["smtp.enable-self-signed-cert"]="SMTP_ENABLE_SELF_SIGNED_CERT"
#
# security-proxy
#
# ADD_PROXY_ROUTE is a csv list of URLs to be added to the
# API Gateway (aka Kong). For references:
#
# https://docs.edgexfoundry.org/1.3/microservices/security/Ch-APIGateway/
#
# TODO: validation
#
conf_to_env["add-proxy-route"]="ADD_PROXY_ROUTE"
#
# security-secret-store
#
# ADD_SECRETSTORE_TOKENS is a csv list of service keys to be added to the
# list of Vault tokens that security-file-token-provider (launched by
# security-secretstore-setup) creates.
#
# TODO: validation
#
conf_to_env["add-secretstore-tokens"]="ADD_SECRETSTORE_TOKENS"

# The syntax to set a configuration key is:
#
# env.<service name>.<section>.<keyname>
# 
# This initial implementation only supports EdgeX core-* and
# support-* services.

# this is a little hackish, but reads better to use string concatenation 
# to build the list of services than have a long string 
ALL_SERVICES=""

# base services
ALL_SERVICES="$ALL_SERVICES consul"
ALL_SERVICES="$ALL_SERVICES redis"

# core services
ALL_SERVICES="$ALL_SERVICES core-data"
ALL_SERVICES="$ALL_SERVICES core-metadata"
ALL_SERVICES="$ALL_SERVICES core-command"

# support services
ALL_SERVICES="$ALL_SERVICES support-notifications"
ALL_SERVICES="$ALL_SERVICES support-scheduler"

# app-services
ALL_SERVICES="$ALL_SERVICES app-service-configurable"

# device services
ALL_SERVICES="$ALL_SERVICES device-virtual"

# security services
ALL_SERVICES="$ALL_SERVICES security-secret-store"
ALL_SERVICES="$ALL_SERVICES security-proxy"

# sys mgmt services
ALL_SERVICES="$ALL_SERVICES sys-mgmt-agent"

# kuiper
ALL_SERVICES="$ALL_SERVICES kuiper"

# handle_svc will either turn a service off or on and set the associated
# config item
# first arg is the service, second is the state to put it in
handle_svc () {
    case "$2" in 
    "off")
        snapctl stop --disable "$SNAP_NAME.$1"
        snapctl set "$1"=off
        ;;
    "on")
        snapctl start --enable "$SNAP_NAME.$1"
        snapctl set "$1"=on
        ;;
    "")
        # no setting for it, ignore and continue
        ;;
    *)
        echo "invalid setting $2 for service $1"
        exit 1;;
    esac
}

handle_config () {
    # the following logic to convert a JSON key/value array to a bash map is
    # based on the following stackoverflow example:
    #
    # https://stackoverflow.com/questions/26717277/converting-a-json-object-into-a-bash-associative-array
    #
    # FIXME: one issue with this implementation is that it strips quotes that may have been specified
    # when 'snap set' was called. This could cause problems with values that contain spaces or other
    # special characters.

    map_init=$(echo $2 | jq -r '. as $in | reduce leaf_paths as $path ({}; . + { ($path | map(tostring) | join(".")): $in | getpath($path) }) | to_entries | map("[\(.key)]=\(.value)") | reduce .[] as $item ("configMap=("; . + ($item|@text) + " ") + ")"')

    logger "edgex:configure: $map_init"

    local service=$1
    local mapAsString
    mapAsString="$map_init"
    local -A "$mapAsString"

    # Handle security-* service naming. The service names in this
    # hook historically do not align with the actual binary commands.
    # As such, when handling configuration settings for them, we need
    # to translate the hook name to the actual binary name.
    #
    if [ "$service" == "security-proxy" ]; then
	service="security-proxy-setup"
    elif [ "$service" == "security-secret-store" ]; then
	service="security-secretstore-setup"
    fi

    file="$SNAP_DATA/config/$service/res/$service.env"

    # if no $service.env file exists, create it
    # TODO: get rid of fore loop, and just access
    # the first (and only) element in the array
    if [ ! -f "$file" ]; then
	logger "edgex:configure: $file NOT FOUND!"
        for ckey in "${!configMap[@]}"; do
            val="${configMap["$ckey"]}"
	    env="${conf_to_env["$ckey"]}"

            # TODO: consider validation of $service & $ckey cominations
	    # Ex. specifying client.support-scheduler for core-data

            logger "edgex:configure: writing $env=$val to $file"
            echo "export $env=$val" > "$file"
            break
        done
    else
        logger "edgex:configure: $file already exists"
        for key in "${!configMap[@]}"; do
            val="${configMap["$key"]}"
	    env="${conf_to_env["$key"]}"

            # TODO: consider validation of $service & $ckey cominations
	    # Ex. specifying client.support-scheduler for core-data

            found=$(grep "$env" "$file")
	    if [ -z "$found" ]; then
		echo "export $env=$val" >> "$file"
	    else
                # The following expression uses a negative
		# address expression to skip updating the line if
		# matches the existing snapd value
		sed -i -e "/export $env=$val/! s@$env=.*@$env=$val@" "$file"
	    fi
        done
    fi
}

for key in $ALL_SERVICES; do
    # get the config key for the service
    status=$(snapctl get "$key")
    config=$(snapctl get "env.$key")

    if [ ! -z "$config" ]; then
        handle_config "$key" "$config"
    fi

    # TODO: most config key changes other than writable.* require service restarts...

    # Does service already have a ENV_OVERRIDES file on disk in $SNAP_DATA/config/<svc>/res?
    # If so, iterate over config keys in $config; for each
    #   - lookup environment override name in conf_to_env map
    #   - is ENV var set in ENV_OVERRIDES already? If yes, is the value the same?
    #   - if different --> update ENV_OVERRIDES
    #   - else continue
    
    case $key in 
        device*)
            # the device services are all using the device-sdk-go which waits
            # for core-data and core-metadata to come online, so if we are 
            # enabling a device service, we should also enable those services
            if [ "$status" = "on" ]; then
                handle_svc "core-data" "on"
                handle_svc "core-metadata" "on"
            fi
            # handle the service too
            handle_svc "$key" "$status"
            ;;
        kuiper)
            # if we are turning kuiper on, make sure
            # app-service-configurable is on too
            if [ "$status" = "on" ]; then
                handle_svc "app-service-configurable" "on"
	    elif [ "$status" = "off" ]; then
                handle_svc "app-service-configurable" "off"
	    fi
            # handle the service too
            handle_svc "$key" "$status"
            ;;
        security-proxy-setup|security-secretstore-setup)
            # it doesn't make any sense to disable the *-worker daemons since 
            # they are just oneshot daemons that run after other daemons, so
            # just ignore this request
            ;;
        security-proxy)
            # the security-proxy consists of the following base services
            # - kong
            # - postgres (because kong requires it)
            handle_svc "postgres" "$status"
            handle_svc "kong-daemon" "$status"
            handle_svc "security-proxy-setup" "$status"
            # additionally, the security-proxy needs to use the following
            # services:
            # - vault (because security-proxy-setup will access/store secrets in vault)
            # - security-secretstore-setup
            # so if we are turning the security-api-gateway on, then turn 
            # those services on too
            if [ "$status" = "on" ]; then
                handle_svc "vault" "on"
                handle_svc "security-secretstore-setup" "on"
            fi
            ;;
        security-secret-store)
            # the security-api-gateway consists of the following services:
            # - vault
            # - security-secretstore-setup
            # and since the security-api-gateway needs to be able to use 
            # security-secret-store, we also need to turn off those services
            # if this one is disabled
            if [ "$status" = "off" ]; then
                handle_svc "postgres" "off"
                handle_svc "kong-daemon" "off"
                handle_svc "security-proxy-setup" "off" 
                # turn off security-secrets-setup too
                handle_svc "security-secrets-setup" "off" 
            fi
            handle_svc "vault" "$status"
            handle_svc "security-secretstore-setup" "$status"
            ;;
        *)
            # default case for all other services just enable/disable the service using
            # snapd/systemd
            # if the service is meant to be off, then disable it
            handle_svc "$key" "$status"
            ;;
    esac
done

